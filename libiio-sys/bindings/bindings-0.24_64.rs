/* automatically generated by rust-bindgen 0.63.0 */

pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iio_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iio_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iio_channel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iio_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iio_context_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iio_scan_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iio_scan_block {
    _unused: [u8; 0],
}
pub const iio_chan_type_IIO_VOLTAGE: iio_chan_type = 0;
pub const iio_chan_type_IIO_CURRENT: iio_chan_type = 1;
pub const iio_chan_type_IIO_POWER: iio_chan_type = 2;
pub const iio_chan_type_IIO_ACCEL: iio_chan_type = 3;
pub const iio_chan_type_IIO_ANGL_VEL: iio_chan_type = 4;
pub const iio_chan_type_IIO_MAGN: iio_chan_type = 5;
pub const iio_chan_type_IIO_LIGHT: iio_chan_type = 6;
pub const iio_chan_type_IIO_INTENSITY: iio_chan_type = 7;
pub const iio_chan_type_IIO_PROXIMITY: iio_chan_type = 8;
pub const iio_chan_type_IIO_TEMP: iio_chan_type = 9;
pub const iio_chan_type_IIO_INCLI: iio_chan_type = 10;
pub const iio_chan_type_IIO_ROT: iio_chan_type = 11;
pub const iio_chan_type_IIO_ANGL: iio_chan_type = 12;
pub const iio_chan_type_IIO_TIMESTAMP: iio_chan_type = 13;
pub const iio_chan_type_IIO_CAPACITANCE: iio_chan_type = 14;
pub const iio_chan_type_IIO_ALTVOLTAGE: iio_chan_type = 15;
pub const iio_chan_type_IIO_CCT: iio_chan_type = 16;
pub const iio_chan_type_IIO_PRESSURE: iio_chan_type = 17;
pub const iio_chan_type_IIO_HUMIDITYRELATIVE: iio_chan_type = 18;
pub const iio_chan_type_IIO_ACTIVITY: iio_chan_type = 19;
pub const iio_chan_type_IIO_STEPS: iio_chan_type = 20;
pub const iio_chan_type_IIO_ENERGY: iio_chan_type = 21;
pub const iio_chan_type_IIO_DISTANCE: iio_chan_type = 22;
pub const iio_chan_type_IIO_VELOCITY: iio_chan_type = 23;
pub const iio_chan_type_IIO_CONCENTRATION: iio_chan_type = 24;
pub const iio_chan_type_IIO_RESISTANCE: iio_chan_type = 25;
pub const iio_chan_type_IIO_PH: iio_chan_type = 26;
pub const iio_chan_type_IIO_UVINDEX: iio_chan_type = 27;
pub const iio_chan_type_IIO_ELECTRICALCONDUCTIVITY: iio_chan_type = 28;
pub const iio_chan_type_IIO_COUNT: iio_chan_type = 29;
pub const iio_chan_type_IIO_INDEX: iio_chan_type = 30;
pub const iio_chan_type_IIO_GRAVITY: iio_chan_type = 31;
pub const iio_chan_type_IIO_POSITIONRELATIVE: iio_chan_type = 32;
pub const iio_chan_type_IIO_PHASE: iio_chan_type = 33;
pub const iio_chan_type_IIO_MASSCONCENTRATION: iio_chan_type = 34;
pub const iio_chan_type_IIO_CHAN_TYPE_UNKNOWN: iio_chan_type = 2147483647;
#[doc = " @enum iio_chan_type\n @brief IIO channel type\n\n A IIO channel has a type specifying the type of data associated with the\n channel."]
pub type iio_chan_type = ::std::os::raw::c_uint;
pub const iio_modifier_IIO_NO_MOD: iio_modifier = 0;
pub const iio_modifier_IIO_MOD_X: iio_modifier = 1;
pub const iio_modifier_IIO_MOD_Y: iio_modifier = 2;
pub const iio_modifier_IIO_MOD_Z: iio_modifier = 3;
pub const iio_modifier_IIO_MOD_X_AND_Y: iio_modifier = 4;
pub const iio_modifier_IIO_MOD_X_AND_Z: iio_modifier = 5;
pub const iio_modifier_IIO_MOD_Y_AND_Z: iio_modifier = 6;
pub const iio_modifier_IIO_MOD_X_AND_Y_AND_Z: iio_modifier = 7;
pub const iio_modifier_IIO_MOD_X_OR_Y: iio_modifier = 8;
pub const iio_modifier_IIO_MOD_X_OR_Z: iio_modifier = 9;
pub const iio_modifier_IIO_MOD_Y_OR_Z: iio_modifier = 10;
pub const iio_modifier_IIO_MOD_X_OR_Y_OR_Z: iio_modifier = 11;
pub const iio_modifier_IIO_MOD_LIGHT_BOTH: iio_modifier = 12;
pub const iio_modifier_IIO_MOD_LIGHT_IR: iio_modifier = 13;
pub const iio_modifier_IIO_MOD_ROOT_SUM_SQUARED_X_Y: iio_modifier = 14;
pub const iio_modifier_IIO_MOD_SUM_SQUARED_X_Y_Z: iio_modifier = 15;
pub const iio_modifier_IIO_MOD_LIGHT_CLEAR: iio_modifier = 16;
pub const iio_modifier_IIO_MOD_LIGHT_RED: iio_modifier = 17;
pub const iio_modifier_IIO_MOD_LIGHT_GREEN: iio_modifier = 18;
pub const iio_modifier_IIO_MOD_LIGHT_BLUE: iio_modifier = 19;
pub const iio_modifier_IIO_MOD_QUATERNION: iio_modifier = 20;
pub const iio_modifier_IIO_MOD_TEMP_AMBIENT: iio_modifier = 21;
pub const iio_modifier_IIO_MOD_TEMP_OBJECT: iio_modifier = 22;
pub const iio_modifier_IIO_MOD_NORTH_MAGN: iio_modifier = 23;
pub const iio_modifier_IIO_MOD_NORTH_TRUE: iio_modifier = 24;
pub const iio_modifier_IIO_MOD_NORTH_MAGN_TILT_COMP: iio_modifier = 25;
pub const iio_modifier_IIO_MOD_NORTH_TRUE_TILT_COMP: iio_modifier = 26;
pub const iio_modifier_IIO_MOD_RUNNING: iio_modifier = 27;
pub const iio_modifier_IIO_MOD_JOGGING: iio_modifier = 28;
pub const iio_modifier_IIO_MOD_WALKING: iio_modifier = 29;
pub const iio_modifier_IIO_MOD_STILL: iio_modifier = 30;
pub const iio_modifier_IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z: iio_modifier = 31;
pub const iio_modifier_IIO_MOD_I: iio_modifier = 32;
pub const iio_modifier_IIO_MOD_Q: iio_modifier = 33;
pub const iio_modifier_IIO_MOD_CO2: iio_modifier = 34;
pub const iio_modifier_IIO_MOD_VOC: iio_modifier = 35;
pub const iio_modifier_IIO_MOD_LIGHT_UV: iio_modifier = 36;
pub const iio_modifier_IIO_MOD_LIGHT_DUV: iio_modifier = 37;
pub const iio_modifier_IIO_MOD_PM1: iio_modifier = 38;
pub const iio_modifier_IIO_MOD_PM2P5: iio_modifier = 39;
pub const iio_modifier_IIO_MOD_PM4: iio_modifier = 40;
pub const iio_modifier_IIO_MOD_PM10: iio_modifier = 41;
pub const iio_modifier_IIO_MOD_ETHANOL: iio_modifier = 42;
pub const iio_modifier_IIO_MOD_H2: iio_modifier = 43;
pub const iio_modifier_IIO_MOD_O2: iio_modifier = 44;
#[doc = " @enum iio_modifier\n @brief IIO channel modifier\n\n In a addition to a type a IIO channel can optionally have a channel modifier\n further specifying the data type of of the channel."]
pub type iio_modifier = ::std::os::raw::c_uint;
pub const iio_event_type_IIO_EV_TYPE_THRESH: iio_event_type = 0;
pub const iio_event_type_IIO_EV_TYPE_MAG: iio_event_type = 1;
pub const iio_event_type_IIO_EV_TYPE_ROC: iio_event_type = 2;
pub const iio_event_type_IIO_EV_TYPE_THRESH_ADAPTIVE: iio_event_type = 3;
pub const iio_event_type_IIO_EV_TYPE_MAG_ADAPTIVE: iio_event_type = 4;
pub const iio_event_type_IIO_EV_TYPE_CHANGE: iio_event_type = 5;
#[doc = " @enum iio_event_type\n @brief IIO event type\n\n Some IIO devices can deliver events. The type of the event can be specified\n by one of the iio_event_type values."]
pub type iio_event_type = ::std::os::raw::c_uint;
pub const iio_event_direction_IIO_EV_DIR_EITHER: iio_event_direction = 0;
pub const iio_event_direction_IIO_EV_DIR_RISING: iio_event_direction = 1;
pub const iio_event_direction_IIO_EV_DIR_FALLING: iio_event_direction = 2;
pub const iio_event_direction_IIO_EV_DIR_NONE: iio_event_direction = 3;
#[doc = " @enum iio_event_direction\n @brief IIO event direction\n\n When applicable, this enum specifies the direction of the iio_event_type."]
pub type iio_event_direction = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Create a scan context\n @param backend A NULL-terminated string containing a comma-separated\n list of the backend(s) to use for scanning.\n @param flags Unused for now. Set to 0.\n @return on success, a pointer to a iio_scan_context structure\n @return On failure, NULL is returned and errno is set appropriately\n\n <b>NOTE:</b> Libiio version 0.20 and above can handle multiple\n strings, for instance \"local:usb:\", \"ip:usb:\", \"local:usb:ip:\", and\n require a colon as the delimiter.\n Libiio version 0.24 and above prefer a comma instead of colon as the\n delimiter, and handle specifying backend-specific information. For\n instance, \"local,usb=0456:*\" will scan the local backend and limit\n scans on USB to vendor ID 0x0456, and accept all product IDs. The\n \"usb=0456:b673\" string would limit the scan to the device with this\n particular VID/PID. Both IDs are expected in hexadecimal, no 0x\n prefix needed."]
    pub fn iio_create_scan_context(
        backend: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> *mut iio_scan_context;
}
extern "C" {
    #[doc = " @brief Destroy the given scan context\n @param ctx A pointer to an iio_scan_context structure\n\n <b>NOTE:</b> After that function, the iio_scan_context pointer shall be invalid."]
    pub fn iio_scan_context_destroy(ctx: *mut iio_scan_context);
}
extern "C" {
    #[doc = " @brief Enumerate available contexts\n @param ctx A pointer to an iio_scan_context structure\n @param info A pointer to a 'const struct iio_context_info **' typed variable.\n The pointed variable will be initialized on success.\n @returns On success, the number of contexts found.\n @returns On failure, a negative error number."]
    pub fn iio_scan_context_get_info_list(
        ctx: *mut iio_scan_context,
        info: *mut *mut *mut iio_context_info,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Free a context info list\n @param info A pointer to a 'const struct iio_context_info *' typed variable"]
    pub fn iio_context_info_list_free(info: *mut *mut iio_context_info);
}
extern "C" {
    #[doc = " @brief Get a description of a discovered context\n @param info A pointer to an iio_context_info structure\n @return A pointer to a static NULL-terminated string"]
    pub fn iio_context_info_get_description(
        info: *const iio_context_info,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the URI of a discovered context\n @param info A pointer to an iio_context_info structure\n @return A pointer to a static NULL-terminated string"]
    pub fn iio_context_info_get_uri(info: *const iio_context_info)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Create a scan block\n @param backend A NULL-terminated string containing the backend to use for\n scanning. If NULL, all the available backends are used.\n @param flags Unused for now. Set to 0.\n @return on success, a pointer to a iio_scan_block structure\n @return On failure, NULL is returned and errno is set appropriately\n\n Introduced in version 0.20."]
    pub fn iio_create_scan_block(
        backend: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> *mut iio_scan_block;
}
extern "C" {
    #[doc = " @brief Destroy the given scan block\n @param blk A pointer to an iio_scan_block structure\n\n <b>NOTE:</b> After that function, the iio_scan_block pointer shall be invalid.\n\n Introduced in version 0.20."]
    pub fn iio_scan_block_destroy(blk: *mut iio_scan_block);
}
extern "C" {
    #[doc = " @brief Enumerate available contexts via scan block\n @param blk A pointer to a iio_scan_block structure.\n @returns On success, the number of contexts found.\n @returns On failure, a negative error number.\n\n Introduced in version 0.20."]
    pub fn iio_scan_block_scan(blk: *mut iio_scan_block) -> isize;
}
extern "C" {
    #[doc = " @brief Get the iio_context_info for a particular context\n @param blk A pointer to an iio_scan_block structure\n @param index The index corresponding to the context.\n @return A pointer to the iio_context_info for the context\n @returns On success, a pointer to the specified iio_context_info\n @returns On failure, NULL is returned and errno is set appropriately\n\n Introduced in version 0.20."]
    pub fn iio_scan_block_get_info(
        blk: *mut iio_scan_block,
        index: ::std::os::raw::c_uint,
    ) -> *mut iio_context_info;
}
extern "C" {
    #[doc = " @brief Get the version of the libiio library\n @param major A pointer to an unsigned integer (NULL accepted)\n @param minor A pointer to an unsigned integer (NULL accepted)\n @param git_tag A pointer to a 8-characters buffer (NULL accepted)"]
    pub fn iio_library_get_version(
        major: *mut ::std::os::raw::c_uint,
        minor: *mut ::std::os::raw::c_uint,
        git_tag: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Get a string description of an error code\n @param err The error code\n @param dst A pointer to the memory area where the NULL-terminated string\n corresponding to the error message will be stored\n @param len The available length of the memory area, in bytes"]
    pub fn iio_strerror(err: ::std::os::raw::c_int, dst: *mut ::std::os::raw::c_char, len: usize);
}
extern "C" {
    #[doc = " @brief Check if the specified backend is available\n @param backend The name of the backend to query\n @return True if the backend is available, false otherwise\n\n Introduced in version 0.9."]
    pub fn iio_has_backend(backend: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " @brief Get the number of available backends\n @return The number of available backends\n\n Introduced in version 0.9."]
    pub fn iio_get_backends_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Retrieve the name of a given backend\n @param index The index corresponding to the attribute\n @return On success, a pointer to a static NULL-terminated string\n @return If the index is invalid, NULL is returned\n\n Introduced in version 0.9."]
    pub fn iio_get_backend(index: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Create a context from local or remote IIO devices\n @return On success, A pointer to an iio_context structure\n @return On failure, NULL is returned and errno is set appropriately\n\n <b>NOTE:</b> This function will create a context with the URI\n provided in the IIOD_REMOTE environment variable. If not set, a local\n context will be created instead."]
    pub fn iio_create_default_context() -> *mut iio_context;
}
extern "C" {
    #[doc = " @brief Create a context from local IIO devices (Linux only)\n @return On success, A pointer to an iio_context structure\n @return On failure, NULL is returned and errno is set appropriately"]
    pub fn iio_create_local_context() -> *mut iio_context;
}
extern "C" {
    #[doc = " @brief Create a context from a XML file\n @param xml_file Path to the XML file to open\n @return On success, A pointer to an iio_context structure\n @return On failure, NULL is returned and errno is set appropriately\n\n <b>NOTE:</b> The format of the XML must comply to the one returned by\n iio_context_get_xml."]
    pub fn iio_create_xml_context(xml_file: *const ::std::os::raw::c_char) -> *mut iio_context;
}
extern "C" {
    #[doc = " @brief Create a context from XML data in memory\n @param xml Pointer to the XML data in memory\n @param len Length of the XML string in memory (excluding the final \\0)\n @return On success, A pointer to an iio_context structure\n @return On failure, NULL is returned and errno is set appropriately\n\n <b>NOTE:</b> The format of the XML must comply to the one returned by\n iio_context_get_xml"]
    pub fn iio_create_xml_context_mem(
        xml: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut iio_context;
}
extern "C" {
    #[doc = " @brief Create a context from the network\n @param host Hostname, IPv4 or IPv6 address where the IIO Daemon is running\n @return On success, a pointer to an iio_context structure\n @return On failure, NULL is returned and errno is set appropriately"]
    pub fn iio_create_network_context(host: *const ::std::os::raw::c_char) -> *mut iio_context;
}
extern "C" {
    #[doc = " @brief Create a context from a URI description\n @param uri A URI describing the context location\n @return On success, a pointer to a iio_context structure\n @return On failure, NULL is returned and errno is set appropriately\n\n <b>NOTE:</b> The following URIs are supported based on compile time backend\n support:\n - Local backend, \"local:\"\\n\n   Does not have an address part. For example <i>\"local:\"</i>\n - XML backend, \"xml:\"\\n Requires a path to the XML file for the address part.\n   For example <i>\"xml:/home/user/file.xml\"</i>\n - Network backend, \"ip:\"\\n Requires a hostname, IPv4, or IPv6 to connect to\n   a specific running IIO Daemon or no address part for automatic discovery\n   when library is compiled with ZeroConf support. For example\n   <i>\"ip:192.168.2.1\"</i>, <b>or</b> <i>\"ip:localhost\"</i>, <b>or</b> <i>\"ip:\"</i>\n   <b>or</b> <i>\"ip:plutosdr.local\"</i>. To support alternative port numbers the\n   standard <i>ip:host:port</i> format is used. A special format is required as\n   defined in RFC2732 for IPv6 literal hostnames, (adding '[]' around the host)\n   to use a <i>ip:[x:x:x:x:x:x:x:x]:port</i> format.\n   Valid examples would be:\n     - ip:                                               Any host on default port\n     - ip::40000                                         Any host on port 40000\n     - ip:analog.local                                   Default port\n     - ip:brain.local:40000                              Port 40000\n     - ip:192.168.1.119                                  Default Port\n     - ip:192.168.1.119:40000                            Port 40000\n     - ip:2601:190:400:da:47b3:55ab:3914:bff1            Default Port\n     - ip:[2601:190:400:da:9a90:96ff:feb5:acaa]:40000    Port 40000\n - USB backend, \"usb:\"\\n When more than one usb device is attached, requires\n   bus, address, and interface parts separated with a dot. For example\n   <i>\"usb:3.32.5\"</i>. Where there is only one USB device attached, the shorthand\n   <i>\"usb:\"</i> can be used.\n - Serial backend, \"serial:\"\\n Requires:\n     - a port (/dev/ttyUSB0),\n     - baud_rate (default <b>115200</b>)\n     - serial port configuration\n        - data bits (5 6 7 <b>8</b> 9)\n        - parity ('<b>n</b>' none, 'o' odd, 'e' even, 'm' mark, 's' space)\n        - stop bits (<b>1</b> 2)\n        - flow control ('<b>\\0</b>' none, 'x' Xon Xoff, 'r' RTSCTS, 'd' DTRDSR)\n\n  For example <i>\"serial:/dev/ttyUSB0,115200\"</i> <b>or</b> <i>\"serial:/dev/ttyUSB0,115200,8n1\"</i>"]
    pub fn iio_create_context_from_uri(uri: *const ::std::os::raw::c_char) -> *mut iio_context;
}
extern "C" {
    #[doc = " @brief Duplicate a pre-existing IIO context\n @param ctx A pointer to an iio_context structure\n @return On success, A pointer to an iio_context structure\n @return On failure, NULL is returned and errno is set appropriately\n\n <b>NOTE:</b> This function is not supported on 'usb:' contexts, since libusb\n can only claim the interface once. \"Function not implemented\" is the expected errno.\n Any context which is cloned, must be destroyed via calling iio_context_destroy()"]
    pub fn iio_context_clone(ctx: *const iio_context) -> *mut iio_context;
}
extern "C" {
    #[doc = " @brief Destroy the given context\n @param ctx A pointer to an iio_context structure\n\n <b>NOTE:</b> After that function, the iio_context pointer shall be invalid."]
    pub fn iio_context_destroy(ctx: *mut iio_context);
}
extern "C" {
    #[doc = " @brief Get the version of the backend in use\n @param ctx A pointer to an iio_context structure\n @param major A pointer to an unsigned integer (NULL accepted)\n @param minor A pointer to an unsigned integer (NULL accepted)\n @param git_tag A pointer to a 8-characters buffer (NULL accepted)\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_context_get_version(
        ctx: *const iio_context,
        major: *mut ::std::os::raw::c_uint,
        minor: *mut ::std::os::raw::c_uint,
        git_tag: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Obtain a XML representation of the given context\n @param ctx A pointer to an iio_context structure\n @return A pointer to a static NULL-terminated string"]
    pub fn iio_context_get_xml(ctx: *const iio_context) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the name of the given context\n @param ctx A pointer to an iio_context structure\n @return A pointer to a static NULL-terminated string\n\n <b>NOTE:</b>The returned string will be <b><i>local</i></b>,\n <b><i>xml</i></b> or <b><i>network</i></b> when the context has been\n created with the local, xml and network backends respectively."]
    pub fn iio_context_get_name(ctx: *const iio_context) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get a description of the given context\n @param ctx A pointer to an iio_context structure\n @return A pointer to a static NULL-terminated string\n\n <b>NOTE:</b>The returned string will contain human-readable information about\n the current context."]
    pub fn iio_context_get_description(ctx: *const iio_context) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the number of context-specific attributes\n @param ctx A pointer to an iio_context structure\n @return The number of context-specific attributes\n\n Introduced in version 0.9."]
    pub fn iio_context_get_attrs_count(ctx: *const iio_context) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Retrieve the name and value of a context-specific attribute\n @param ctx A pointer to an iio_context structure\n @param index The index corresponding to the attribute\n @param name A pointer to a const char * pointer (NULL accepted)\n @param value A pointer to a const char * pointer (NULL accepted)\n @return On success, 0 is returned\n @return On error, a negative errno code is returned\n\n Introduced in version 0.9."]
    pub fn iio_context_get_attr(
        ctx: *const iio_context,
        index: ::std::os::raw::c_uint,
        name: *mut *const ::std::os::raw::c_char,
        value: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the value of a context-specific attribute\n @param ctx A pointer to an iio_context structure\n @param name The name of the context attribute to read\n @return On success, a pointer to a static NULL-terminated string\n @return If the name does not correspond to any attribute, NULL is\n returned\n\n Introduced in version 0.9."]
    pub fn iio_context_get_attr_value(
        ctx: *const iio_context,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Enumerate the devices found in the given context\n @param ctx A pointer to an iio_context structure\n @return The number of devices found"]
    pub fn iio_context_get_devices_count(ctx: *const iio_context) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Get the device present at the given index\n @param ctx A pointer to an iio_context structure\n @param index The index corresponding to the device\n @return On success, a pointer to an iio_device structure\n @return If the index is invalid, NULL is returned"]
    pub fn iio_context_get_device(
        ctx: *const iio_context,
        index: ::std::os::raw::c_uint,
    ) -> *mut iio_device;
}
extern "C" {
    #[doc = " @brief Try to find a device structure by its ID, label or name\n @param ctx A pointer to an iio_context structure\n @param name A NULL-terminated string corresponding to the ID, label or name\n of the device to search for\n @return On success, a pointer to an iio_device structure\n @return If the parameter does not correspond to the ID, label or name of\n any known device, NULL is returned"]
    pub fn iio_context_find_device(
        ctx: *const iio_context,
        name: *const ::std::os::raw::c_char,
    ) -> *mut iio_device;
}
extern "C" {
    #[doc = " @brief Set a timeout for I/O operations\n @param ctx A pointer to an iio_context structure\n @param timeout_ms A positive integer representing the time in milliseconds\n after which a timeout occurs. A value of 0 is used to specify that no\n timeout should occur.\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_context_set_timeout(
        ctx: *mut iio_context,
        timeout_ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve a pointer to the iio_context structure\n @param dev A pointer to an iio_device structure\n @return A pointer to an iio_context structure"]
    pub fn iio_device_get_context(dev: *const iio_device) -> *const iio_context;
}
extern "C" {
    #[doc = " @brief Retrieve the device ID (e.g. <b><i>iio:device0</i></b>)\n @param dev A pointer to an iio_device structure\n @return A pointer to a static NULL-terminated string"]
    pub fn iio_device_get_id(dev: *const iio_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Retrieve the device name (e.g. <b><i>xadc</i></b>)\n @param dev A pointer to an iio_device structure\n @return A pointer to a static NULL-terminated string\n\n <b>NOTE:</b> if the device has no name, NULL is returned."]
    pub fn iio_device_get_name(dev: *const iio_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Retrieve the device label (e.g. <b><i>lo_pll0_rx_adf4351</i></b>)\n @param dev A pointer to an iio_device structure\n @return A pointer to a static NULL-terminated string\n\n <b>NOTE:</b> if the device has no label, NULL is returned."]
    pub fn iio_device_get_label(dev: *const iio_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Enumerate the channels of the given device\n @param dev A pointer to an iio_device structure\n @return The number of channels found"]
    pub fn iio_device_get_channels_count(dev: *const iio_device) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Enumerate the device-specific attributes of the given device\n @param dev A pointer to an iio_device structure\n @return The number of device-specific attributes found"]
    pub fn iio_device_get_attrs_count(dev: *const iio_device) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Enumerate the buffer-specific attributes of the given device\n @param dev A pointer to an iio_device structure\n @return The number of buffer-specific attributes found"]
    pub fn iio_device_get_buffer_attrs_count(dev: *const iio_device) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Get the channel present at the given index\n @param dev A pointer to an iio_device structure\n @param index The index corresponding to the channel\n @return On success, a pointer to an iio_channel structure\n @return If the index is invalid, NULL is returned"]
    pub fn iio_device_get_channel(
        dev: *const iio_device,
        index: ::std::os::raw::c_uint,
    ) -> *mut iio_channel;
}
extern "C" {
    #[doc = " @brief Get the device-specific attribute present at the given index\n @param dev A pointer to an iio_device structure\n @param index The index corresponding to the attribute\n @return On success, a pointer to a static NULL-terminated string\n @return If the index is invalid, NULL is returned"]
    pub fn iio_device_get_attr(
        dev: *const iio_device,
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the buffer-specific attribute present at the given index\n @param dev A pointer to an iio_device structure\n @param index The index corresponding to the attribute\n @return On success, a pointer to a static NULL-terminated string\n @return If the index is invalid, NULL is returned"]
    pub fn iio_device_get_buffer_attr(
        dev: *const iio_device,
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Try to find a channel structure by its name of ID\n @param dev A pointer to an iio_device structure\n @param name A NULL-terminated string corresponding to the name or the ID of\n the channel to search for\n @param output True if the searched channel is output, False otherwise\n @return On success, a pointer to an iio_channel structure\n @return If the name or ID does not correspond to any known channel of the\n given device, NULL is returned"]
    pub fn iio_device_find_channel(
        dev: *const iio_device,
        name: *const ::std::os::raw::c_char,
        output: bool,
    ) -> *mut iio_channel;
}
extern "C" {
    #[doc = " @brief Try to find a device-specific attribute by its name\n @param dev A pointer to an iio_device structure\n @param name A NULL-terminated string corresponding to the name of the\n attribute\n @return On success, a pointer to a static NULL-terminated string\n @return If the name does not correspond to any known attribute of the given\n device, NULL is returned\n\n <b>NOTE:</b> This function is useful to detect the presence of an attribute.\n It can also be used to retrieve the name of an attribute as a pointer to a\n static string from a dynamically allocated string."]
    pub fn iio_device_find_attr(
        dev: *const iio_device,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Try to find a buffer-specific attribute by its name\n @param dev A pointer to an iio_device structure\n @param name A NULL-terminated string corresponding to the name of the\n attribute\n @return On success, a pointer to a static NULL-terminated string\n @return If the name does not correspond to any known attribute of the given\n device, NULL is returned\n\n <b>NOTE:</b> This function is useful to detect the presence of an attribute.\n It can also be used to retrieve the name of an attribute as a pointer to a\n static string from a dynamically allocated string."]
    pub fn iio_device_find_buffer_attr(
        dev: *const iio_device,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Read the content of the given device-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param dst A pointer to the memory area where the NULL-terminated string\n corresponding to the value read will be stored\n @param len The available length of the memory area, in bytes\n @return On success, the number of bytes written to the buffer\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b>By passing NULL as the \"attr\" argument to iio_device_attr_read,\n it is now possible to read all of the attributes of a device.\n\n The buffer is filled with one block of data per attribute of the device,\n by the order they appear in the iio_device structure.\n\n The first four bytes of one block correspond to a 32-bit signed value in\n network order. If negative, it corresponds to the errno code that were\n returned when reading the attribute; if positive, it corresponds to the\n length of the data read. In that case, the rest of the block contains\n the data."]
    pub fn iio_device_attr_read(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Read the content of all device-specific attributes\n @param dev A pointer to an iio_device structure\n @param cb A pointer to a callback function\n @param data A pointer that will be passed to the callback function\n @return On success, 0 is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> This function is especially useful when used with the network\n backend, as all the device-specific attributes are read in one single\n command."]
    pub fn iio_device_attr_read_all(
        dev: *mut iio_device,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                dev: *mut iio_device,
                attr: *const ::std::os::raw::c_char,
                value: *const ::std::os::raw::c_char,
                len: usize,
                d: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given device-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A pointer to a bool variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_attr_read_bool(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given device-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A pointer to a long long variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_attr_read_longlong(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given device-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A pointer to a double variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_attr_read_double(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given device-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param src A NULL-terminated string to set the attribute to\n @return On success, the number of bytes written\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b>By passing NULL as the \"attr\" argument to iio_device_attr_write,\n it is now possible to write all of the attributes of a device.\n\n The buffer must contain one block of data per attribute of the device,\n by the order they appear in the iio_device structure.\n\n The first four bytes of one block correspond to a 32-bit signed value in\n network order. If negative, the attribute is not written; if positive,\n it corresponds to the length of the data to write. In that case, the rest\n of the block must contain the data."]
    pub fn iio_device_attr_write(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Set the value of the given device-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param src A pointer to the data to be written\n @param len The number of bytes that should be written\n @return On success, the number of bytes written\n @return On error, a negative errno code is returned"]
    pub fn iio_device_attr_write_raw(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Set the values of all device-specific attributes\n @param dev A pointer to an iio_device structure\n @param cb A pointer to a callback function\n @param data A pointer that will be passed to the callback function\n @return On success, 0 is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> This function is especially useful when used with the network\n backend, as all the device-specific attributes are written in one single\n command."]
    pub fn iio_device_attr_write_all(
        dev: *mut iio_device,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                dev: *mut iio_device,
                attr: *const ::std::os::raw::c_char,
                buf: *mut ::std::os::raw::c_void,
                len: usize,
                d: *mut ::std::os::raw::c_void,
            ) -> isize,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given device-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A bool value to set the attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_attr_write_bool(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given device-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A long long value to set the attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_attr_write_longlong(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given device-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A double value to set the attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_attr_write_double(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given buffer-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param dst A pointer to the memory area where the NULL-terminated string\n corresponding to the value read will be stored\n @param len The available length of the memory area, in bytes\n @return On success, the number of bytes written to the buffer\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b>By passing NULL as the \"attr\" argument to\n iio_device_buffer_attr_read, it is now possible to read all of the attributes\n of a device.\n\n The buffer is filled with one block of data per attribute of the buffer,\n by the order they appear in the iio_device structure.\n\n The first four bytes of one block correspond to a 32-bit signed value in\n network order. If negative, it corresponds to the errno code that were\n returned when reading the attribute; if positive, it corresponds to the\n length of the data read. In that case, the rest of the block contains\n the data."]
    pub fn iio_device_buffer_attr_read(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Read the content of all buffer-specific attributes\n @param dev A pointer to an iio_device structure\n @param cb A pointer to a callback function\n @param data A pointer that will be passed to the callback function\n @return On success, 0 is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> This function is especially useful when used with the network\n backend, as all the buffer-specific attributes are read in one single\n command."]
    pub fn iio_device_buffer_attr_read_all(
        dev: *mut iio_device,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                dev: *mut iio_device,
                attr: *const ::std::os::raw::c_char,
                value: *const ::std::os::raw::c_char,
                len: usize,
                d: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given buffer-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A pointer to a bool variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_buffer_attr_read_bool(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given buffer-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A pointer to a long long variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_buffer_attr_read_longlong(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given buffer-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A pointer to a double variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_buffer_attr_read_double(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given buffer-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param src A NULL-terminated string to set the attribute to\n @return On success, the number of bytes written\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b>By passing NULL as the \"attr\" argument to\n iio_device_buffer_attr_write, it is now possible to write all of the\n attributes of a device.\n\n The buffer must contain one block of data per attribute of the buffer,\n by the order they appear in the iio_device structure.\n\n The first four bytes of one block correspond to a 32-bit signed value in\n network order. If negative, the attribute is not written; if positive,\n it corresponds to the length of the data to write. In that case, the rest\n of the block must contain the data."]
    pub fn iio_device_buffer_attr_write(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Set the value of the given buffer-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param src A pointer to the data to be written\n @param len The number of bytes that should be written\n @return On success, the number of bytes written\n @return On error, a negative errno code is returned"]
    pub fn iio_device_buffer_attr_write_raw(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Set the values of all buffer-specific attributes\n @param dev A pointer to an iio_device structure\n @param cb A pointer to a callback function\n @param data A pointer that will be passed to the callback function\n @return On success, 0 is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> This function is especially useful when used with the network\n backend, as all the buffer-specific attributes are written in one single\n command."]
    pub fn iio_device_buffer_attr_write_all(
        dev: *mut iio_device,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                dev: *mut iio_device,
                attr: *const ::std::os::raw::c_char,
                buf: *mut ::std::os::raw::c_void,
                len: usize,
                d: *mut ::std::os::raw::c_void,
            ) -> isize,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given buffer-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A bool value to set the attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_buffer_attr_write_bool(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given buffer-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A long long value to set the attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_buffer_attr_write_longlong(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given buffer-specific attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A double value to set the attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_buffer_attr_write_double(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Associate a pointer to an iio_device structure\n @param dev A pointer to an iio_device structure\n @param data The pointer to be associated"]
    pub fn iio_device_set_data(dev: *mut iio_device, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Retrieve a previously associated pointer of an iio_device structure\n @param dev A pointer to an iio_device structure\n @return The pointer previously associated if present, or NULL"]
    pub fn iio_device_get_data(dev: *const iio_device) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Retrieve the trigger of a given device\n @param dev A pointer to an iio_device structure\n @param trigger a pointer to a pointer of an iio_device structure. The pointed\n pointer will be set to the address of the iio_device structure corresponding\n to the associated trigger device.\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_get_trigger(
        dev: *const iio_device,
        trigger: *mut *const iio_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Associate a trigger to a given device\n @param dev A pointer to an iio_device structure\n @param trigger a pointer to the iio_device structure corresponding to the\n trigger that should be associated.\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_set_trigger(
        dev: *const iio_device,
        trigger: *const iio_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return True if the given device is a trigger\n @param dev A pointer to an iio_device structure\n @return True if the device is a trigger, False otherwise"]
    pub fn iio_device_is_trigger(dev: *const iio_device) -> bool;
}
extern "C" {
    #[doc = " @brief Configure the number of kernel buffers for a device\n\n This function allows to change the number of buffers on kernel side.\n @param dev A pointer to an iio_device structure\n @param nb_buffers The number of buffers\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_set_kernel_buffers_count(
        dev: *const iio_device,
        nb_buffers: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve a pointer to the iio_device structure\n @param chn A pointer to an iio_channel structure\n @return A pointer to an iio_device structure"]
    pub fn iio_channel_get_device(chn: *const iio_channel) -> *const iio_device;
}
extern "C" {
    #[doc = " @brief Retrieve the channel ID (e.g. <b><i>voltage0</i></b>)\n @param chn A pointer to an iio_channel structure\n @return A pointer to a static NULL-terminated string"]
    pub fn iio_channel_get_id(chn: *const iio_channel) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Retrieve the channel name (e.g. <b><i>vccint</i></b>)\n @param chn A pointer to an iio_channel structure\n @return A pointer to a static NULL-terminated string\n\n <b>NOTE:</b> if the channel has no name, NULL is returned."]
    pub fn iio_channel_get_name(chn: *const iio_channel) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return True if the given channel is an output channel\n @param chn A pointer to an iio_channel structure\n @return True if the channel is an output channel, False otherwise"]
    pub fn iio_channel_is_output(chn: *const iio_channel) -> bool;
}
extern "C" {
    #[doc = " @brief Return True if the given channel is a scan element\n @param chn A pointer to an iio_channel structure\n @return True if the channel is a scan element, False otherwise\n\n <b>NOTE:</b> a channel that is a scan element is a channel that can\n generate samples (for an input channel) or receive samples (for an output\n channel) after being enabled."]
    pub fn iio_channel_is_scan_element(chn: *const iio_channel) -> bool;
}
extern "C" {
    #[doc = " @brief Enumerate the channel-specific attributes of the given channel\n @param chn A pointer to an iio_channel structure\n @return The number of channel-specific attributes found"]
    pub fn iio_channel_get_attrs_count(chn: *const iio_channel) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Get the channel-specific attribute present at the given index\n @param chn A pointer to an iio_channel structure\n @param index The index corresponding to the attribute\n @return On success, a pointer to a static NULL-terminated string\n @return If the index is invalid, NULL is returned"]
    pub fn iio_channel_get_attr(
        chn: *const iio_channel,
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Try to find a channel-specific attribute by its name\n @param chn A pointer to an iio_channel structure\n @param name A NULL-terminated string corresponding to the name of the\n attribute\n @return On success, a pointer to a static NULL-terminated string\n @return If the name does not correspond to any known attribute of the given\n channel, NULL is returned\n\n <b>NOTE:</b> This function is useful to detect the presence of an attribute.\n It can also be used to retrieve the name of an attribute as a pointer to a\n static string from a dynamically allocated string."]
    pub fn iio_channel_find_attr(
        chn: *const iio_channel,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Retrieve the filename of an attribute\n @param chn A pointer to an iio_channel structure\n @param attr a NULL-terminated string corresponding to the name of the\n attribute\n @return On success, a pointer to a static NULL-terminated string\n @return If the attribute name is unknown, NULL is returned"]
    pub fn iio_channel_attr_get_filename(
        chn: *const iio_channel,
        attr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Read the content of the given channel-specific attribute\n @param chn A pointer to an iio_channel structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param dst A pointer to the memory area where the NULL-terminated string\n corresponding to the value read will be stored\n @param len The available length of the memory area, in bytes\n @return On success, the number of bytes written to the buffer\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b>By passing NULL as the \"attr\" argument to iio_channel_attr_read,\n it is now possible to read all of the attributes of a channel.\n\n The buffer is filled with one block of data per attribute of the channel,\n by the order they appear in the iio_channel structure.\n\n The first four bytes of one block correspond to a 32-bit signed value in\n network order. If negative, it corresponds to the errno code that were\n returned when reading the attribute; if positive, it corresponds to the\n length of the data read. In that case, the rest of the block contains\n the data."]
    pub fn iio_channel_attr_read(
        chn: *const iio_channel,
        attr: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Read the content of all channel-specific attributes\n @param chn A pointer to an iio_channel structure\n @param cb A pointer to a callback function\n @param data A pointer that will be passed to the callback function\n @return On success, 0 is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> This function is especially useful when used with the network\n backend, as all the channel-specific attributes are read in one single\n command."]
    pub fn iio_channel_attr_read_all(
        chn: *mut iio_channel,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                chn: *mut iio_channel,
                attr: *const ::std::os::raw::c_char,
                val: *const ::std::os::raw::c_char,
                len: usize,
                d: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given channel-specific attribute\n @param chn A pointer to an iio_channel structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A pointer to a bool variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_channel_attr_read_bool(
        chn: *const iio_channel,
        attr: *const ::std::os::raw::c_char,
        val: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given channel-specific attribute\n @param chn A pointer to an iio_channel structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A pointer to a long long variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_channel_attr_read_longlong(
        chn: *const iio_channel,
        attr: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given channel-specific attribute\n @param chn A pointer to an iio_channel structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A pointer to a double variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_channel_attr_read_double(
        chn: *const iio_channel,
        attr: *const ::std::os::raw::c_char,
        val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given channel-specific attribute\n @param chn A pointer to an iio_channel structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param src A NULL-terminated string to set the attribute to\n @return On success, the number of bytes written\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b>By passing NULL as the \"attr\" argument to iio_channel_attr_write,\n it is now possible to write all of the attributes of a channel.\n\n The buffer must contain one block of data per attribute of the channel,\n by the order they appear in the iio_channel structure.\n\n The first four bytes of one block correspond to a 32-bit signed value in\n network order. If negative, the attribute is not written; if positive,\n it corresponds to the length of the data to write. In that case, the rest\n of the block must contain the data."]
    pub fn iio_channel_attr_write(
        chn: *const iio_channel,
        attr: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Set the value of the given channel-specific attribute\n @param chn A pointer to an iio_channel structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param src A pointer to the data to be written\n @param len The number of bytes that should be written\n @return On success, the number of bytes written\n @return On error, a negative errno code is returned"]
    pub fn iio_channel_attr_write_raw(
        chn: *const iio_channel,
        attr: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Set the values of all channel-specific attributes\n @param chn A pointer to an iio_channel structure\n @param cb A pointer to a callback function\n @param data A pointer that will be passed to the callback function\n @return On success, 0 is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> This function is especially useful when used with the network\n backend, as all the channel-specific attributes are written in one single\n command."]
    pub fn iio_channel_attr_write_all(
        chn: *mut iio_channel,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                chn: *mut iio_channel,
                attr: *const ::std::os::raw::c_char,
                buf: *mut ::std::os::raw::c_void,
                len: usize,
                d: *mut ::std::os::raw::c_void,
            ) -> isize,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given channel-specific attribute\n @param chn A pointer to an iio_channel structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A bool value to set the attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_channel_attr_write_bool(
        chn: *const iio_channel,
        attr: *const ::std::os::raw::c_char,
        val: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given channel-specific attribute\n @param chn A pointer to an iio_channel structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A long long value to set the attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_channel_attr_write_longlong(
        chn: *const iio_channel,
        attr: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given channel-specific attribute\n @param chn A pointer to an iio_channel structure\n @param attr A NULL-terminated string corresponding to the name of the\n attribute\n @param val A double value to set the attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_channel_attr_write_double(
        chn: *const iio_channel,
        attr: *const ::std::os::raw::c_char,
        val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable the given channel\n @param chn A pointer to an iio_channel structure\n\n <b>NOTE:</b>Before creating an iio_buffer structure with\n iio_device_create_buffer, it is required to enable at least one channel of\n the device to read from."]
    pub fn iio_channel_enable(chn: *mut iio_channel);
}
extern "C" {
    #[doc = " @brief Disable the given channel\n @param chn A pointer to an iio_channel structure"]
    pub fn iio_channel_disable(chn: *mut iio_channel);
}
extern "C" {
    #[doc = " @brief Returns True if the channel is enabled\n @param chn A pointer to an iio_channel structure\n @return True if the channel is enabled, False otherwise"]
    pub fn iio_channel_is_enabled(chn: *const iio_channel) -> bool;
}
extern "C" {
    #[doc = " @brief Demultiplex the samples of a given channel\n @param chn A pointer to an iio_channel structure\n @param buffer A pointer to an iio_buffer structure\n @param dst A pointer to the memory area where the demultiplexed data will be\n stored\n @param len The available length of the memory area, in bytes\n @return The size of the demultiplexed data, in bytes"]
    pub fn iio_channel_read_raw(
        chn: *const iio_channel,
        buffer: *mut iio_buffer,
        dst: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Demultiplex and convert the samples of a given channel\n @param chn A pointer to an iio_channel structure\n @param buffer A pointer to an iio_buffer structure\n @param dst A pointer to the memory area where the converted data will be\n stored\n @param len The available length of the memory area, in bytes\n @return The size of the converted data, in bytes"]
    pub fn iio_channel_read(
        chn: *const iio_channel,
        buffer: *mut iio_buffer,
        dst: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Multiplex the samples of a given channel\n @param chn A pointer to an iio_channel structure\n @param buffer A pointer to an iio_buffer structure\n @param src A pointer to the memory area where the sequential data will\n be read from\n @param len The length of the memory area, in bytes\n @return The number of bytes actually multiplexed"]
    pub fn iio_channel_write_raw(
        chn: *const iio_channel,
        buffer: *mut iio_buffer,
        src: *const ::std::os::raw::c_void,
        len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Convert and multiplex the samples of a given channel\n @param chn A pointer to an iio_channel structure\n @param buffer A pointer to an iio_buffer structure\n @param src A pointer to the memory area where the sequential data will\n be read from\n @param len The length of the memory area, in bytes\n @return The number of bytes actually converted and multiplexed"]
    pub fn iio_channel_write(
        chn: *const iio_channel,
        buffer: *mut iio_buffer,
        src: *const ::std::os::raw::c_void,
        len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Associate a pointer to an iio_channel structure\n @param chn A pointer to an iio_channel structure\n @param data The pointer to be associated"]
    pub fn iio_channel_set_data(chn: *mut iio_channel, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Retrieve a previously associated pointer of an iio_channel structure\n @param chn A pointer to an iio_channel structure\n @return The pointer previously associated if present, or NULL"]
    pub fn iio_channel_get_data(chn: *const iio_channel) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Get the type of the given channel\n @param chn A pointer to an iio_channel structure\n @return The type of the channel"]
    pub fn iio_channel_get_type(chn: *const iio_channel) -> iio_chan_type;
}
extern "C" {
    #[doc = " @brief Get the modifier type of the given channel\n @param chn A pointer to an iio_channel structure\n @return The modifier type of the channel"]
    pub fn iio_channel_get_modifier(chn: *const iio_channel) -> iio_modifier;
}
extern "C" {
    #[doc = " @brief Retrieve a pointer to the iio_device structure\n @param buf A pointer to an iio_buffer structure\n @return A pointer to an iio_device structure"]
    pub fn iio_buffer_get_device(buf: *const iio_buffer) -> *const iio_device;
}
extern "C" {
    #[doc = " @brief Create an input or output buffer associated to the given device\n @param dev A pointer to an iio_device structure\n @param samples_count The number of samples that the buffer should contain\n @param cyclic If True, enable cyclic mode\n @return On success, a pointer to an iio_buffer structure\n @return On error, NULL is returned, and errno is set to the error code\n\n <b>NOTE:</b> Channels that have to be written to / read from must be enabled\n before creating the buffer."]
    pub fn iio_device_create_buffer(
        dev: *const iio_device,
        samples_count: usize,
        cyclic: bool,
    ) -> *mut iio_buffer;
}
extern "C" {
    #[doc = " @brief Destroy the given buffer\n @param buf A pointer to an iio_buffer structure\n\n <b>NOTE:</b> After that function, the iio_buffer pointer shall be invalid."]
    pub fn iio_buffer_destroy(buf: *mut iio_buffer);
}
extern "C" {
    #[doc = " @brief Get a pollable file descriptor\n\n Can be used to know when iio_buffer_refill() or iio_buffer_push() can be\n called\n @param buf A pointer to an iio_buffer structure\n @return On success, valid file descriptor\n @return On error, a negative errno code is returned"]
    pub fn iio_buffer_get_poll_fd(buf: *mut iio_buffer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Make iio_buffer_refill() and iio_buffer_push() blocking or not\n\n After this function has been called with blocking == false,\n iio_buffer_refill() and iio_buffer_push() will return -EAGAIN if no data is\n ready.\n A device is blocking by default.\n @param buf A pointer to an iio_buffer structure\n @param blocking true if the buffer API should be blocking, else false\n @return On success, 0\n @return On error, a negative errno code is returned"]
    pub fn iio_buffer_set_blocking_mode(
        buf: *mut iio_buffer,
        blocking: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Fetch more samples from the hardware\n @param buf A pointer to an iio_buffer structure\n @return On success, the number of bytes read is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> Only valid for input buffers"]
    pub fn iio_buffer_refill(buf: *mut iio_buffer) -> isize;
}
extern "C" {
    #[doc = " @brief Send the samples to the hardware\n @param buf A pointer to an iio_buffer structure\n @return On success, the number of bytes written is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> Only valid for output buffers"]
    pub fn iio_buffer_push(buf: *mut iio_buffer) -> isize;
}
extern "C" {
    #[doc = " @brief Send a given number of samples to the hardware\n @param buf A pointer to an iio_buffer structure\n @param samples_count The number of samples to submit\n @return On success, the number of bytes written is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> Only valid for output buffers"]
    pub fn iio_buffer_push_partial(buf: *mut iio_buffer, samples_count: usize) -> isize;
}
extern "C" {
    #[doc = " @brief Cancel all buffer operations\n @param buf The buffer for which operations should be canceled\n\n This function cancels all outstanding buffer operations previously scheduled.\n This means any pending iio_buffer_push() or iio_buffer_refill() operation\n will abort and return immediately, any further invocations of these functions\n on the same buffer will return immediately with an error.\n\n Usually iio_buffer_push() and iio_buffer_refill() will block until either all\n data has been transferred or a timeout occurs. This can depending on the\n configuration take a significant amount of time. iio_buffer_cancel() is\n useful to bypass these conditions if the buffer operation is supposed to be\n stopped in response to an external event (e.g. user input).\n\n To be able to capture additional data after calling this function the buffer\n should be destroyed and then re-created.\n\n This function can be called multiple times for the same buffer, but all but\n the first invocation will be without additional effect.\n\n This function is thread-safe, but not signal-safe, i.e. it must not be called\n from a signal handler."]
    pub fn iio_buffer_cancel(buf: *mut iio_buffer);
}
extern "C" {
    #[doc = " @brief Get the start address of the buffer\n @param buf A pointer to an iio_buffer structure\n @return A pointer corresponding to the start address of the buffer"]
    pub fn iio_buffer_start(buf: *const iio_buffer) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Find the first sample of a channel in a buffer\n @param buf A pointer to an iio_buffer structure\n @param chn A pointer to an iio_channel structure\n @return A pointer to the first sample found, or to the end of the buffer if\n no sample for the given channel is present in the buffer\n\n <b>NOTE:</b> This function, coupled with iio_buffer_step and iio_buffer_end,\n can be used to iterate on all the samples of a given channel present in the\n buffer, doing the following:\n\n @verbatim\nfor (void *ptr = iio_buffer_first(buffer, chn); ptr < iio_buffer_end(buffer); ptr += iio_buffer_step(buffer)) {\n....\n}\n@endverbatim"]
    pub fn iio_buffer_first(
        buf: *const iio_buffer,
        chn: *const iio_channel,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Get the step size between two samples of one channel\n @param buf A pointer to an iio_buffer structure\n @return the difference between the addresses of two consecutive samples of\n one same channel"]
    pub fn iio_buffer_step(buf: *const iio_buffer) -> isize;
}
extern "C" {
    #[doc = " @brief Get the address that follows the last sample in a buffer\n @param buf A pointer to an iio_buffer structure\n @return A pointer corresponding to the address that follows the last sample\n present in the buffer"]
    pub fn iio_buffer_end(buf: *const iio_buffer) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Call the supplied callback for each sample found in a buffer\n @param buf A pointer to an iio_buffer structure\n @param callback A pointer to a function to call for each sample found\n @param data A user-specified pointer that will be passed to the callback\n @return number of bytes processed.\n\n <b>NOTE:</b> The callback receives four arguments:\n * A pointer to the iio_channel structure corresponding to the sample,\n * A pointer to the sample itself,\n * The length of the sample in bytes,\n * The user-specified pointer passed to iio_buffer_foreach_sample."]
    pub fn iio_buffer_foreach_sample(
        buf: *mut iio_buffer,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                chn: *const iio_channel,
                src: *mut ::std::os::raw::c_void,
                bytes: usize,
                d: *mut ::std::os::raw::c_void,
            ) -> isize,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Associate a pointer to an iio_buffer structure\n @param buf A pointer to an iio_buffer structure\n @param data The pointer to be associated"]
    pub fn iio_buffer_set_data(buf: *mut iio_buffer, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Retrieve a previously associated pointer of an iio_buffer structure\n @param buf A pointer to an iio_buffer structure\n @return The pointer previously associated if present, or NULL"]
    pub fn iio_buffer_get_data(buf: *const iio_buffer) -> *mut ::std::os::raw::c_void;
}
pub const hwmon_chan_type_HWMON_VOLTAGE: hwmon_chan_type = 0;
pub const hwmon_chan_type_HWMON_FAN: hwmon_chan_type = 1;
pub const hwmon_chan_type_HWMON_PWM: hwmon_chan_type = 2;
pub const hwmon_chan_type_HWMON_TEMP: hwmon_chan_type = 3;
pub const hwmon_chan_type_HWMON_CURRENT: hwmon_chan_type = 4;
pub const hwmon_chan_type_HWMON_POWER: hwmon_chan_type = 5;
pub const hwmon_chan_type_HWMON_ENERGY: hwmon_chan_type = 6;
pub const hwmon_chan_type_HWMON_HUMIDITY: hwmon_chan_type = 7;
pub const hwmon_chan_type_HWMON_INTRUSION: hwmon_chan_type = 8;
pub const hwmon_chan_type_HWMON_CHAN_TYPE_UNKNOWN: hwmon_chan_type = 2147483647;
#[doc = " @defgroup Hwmon Compatibility with hardware monitoring (hwmon) devices\n @{\n @enum hwmon_chan_type\n @brief Hwmon channel type\n\n Libiio support hardware-monitoring (hwmon) devices as well. This enum\n specifies the type of data associated with the hwmon channel.\n\n NOTE: as of 2021 only the current hwmon API is supported. The old\n and deprecated APIs are not supported, and won't be supported unless we\n have a case where updating a hwmon driver is not possible."]
pub type hwmon_chan_type = ::std::os::raw::c_uint;
#[doc = " @defgroup Debug Debug and low-level functions\n @{\n @struct iio_data_format\n @brief Contains the format of a data sample.\n\n The different fields inform about the correct way to convert one sample from\n its raw format (as read from / generated by the hardware) to its real-world\n value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iio_data_format {
    #[doc = " @brief Total length of the sample, in bits"]
    pub length: ::std::os::raw::c_uint,
    #[doc = " @brief Length of valuable data in the sample, in bits"]
    pub bits: ::std::os::raw::c_uint,
    #[doc = " @brief Right-shift to apply when converting sample"]
    pub shift: ::std::os::raw::c_uint,
    #[doc = " @brief Contains True if the sample is signed"]
    pub is_signed: bool,
    #[doc = " @brief Contains True if the sample is fully defined, sign extended, etc."]
    pub is_fully_defined: bool,
    #[doc = " @brief Contains True if the sample is in big-endian format"]
    pub is_be: bool,
    #[doc = " @brief Contains True if the sample should be scaled when converted"]
    pub with_scale: bool,
    #[doc = " @brief Contains the scale to apply if with_scale is set"]
    pub scale: f64,
    #[doc = " @brief Number of times length repeats (added in v0.8)"]
    pub repeat: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_iio_data_format() {
    const UNINIT: ::std::mem::MaybeUninit<iio_data_format> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iio_data_format>(),
        32usize,
        concat!("Size of: ", stringify!(iio_data_format))
    );
    assert_eq!(
        ::std::mem::align_of::<iio_data_format>(),
        8usize,
        concat!("Alignment of ", stringify!(iio_data_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iio_data_format),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iio_data_format),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shift) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iio_data_format),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_signed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(iio_data_format),
            "::",
            stringify!(is_signed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_fully_defined) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(iio_data_format),
            "::",
            stringify!(is_fully_defined)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_be) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(iio_data_format),
            "::",
            stringify!(is_be)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).with_scale) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(iio_data_format),
            "::",
            stringify!(with_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iio_data_format),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).repeat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iio_data_format),
            "::",
            stringify!(repeat)
        )
    );
}
extern "C" {
    #[doc = " @brief Get the current sample size\n @param dev A pointer to an iio_device structure\n @return On success, the sample size in bytes\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> The sample size is not constant and will change when channels\n get enabled or disabled."]
    pub fn iio_device_get_sample_size(dev: *const iio_device) -> isize;
}
extern "C" {
    #[doc = " @brief Get the index of the given channel\n @param chn A pointer to an iio_channel structure\n @return On success, the index of the specified channel\n @return On error, a negative errno code is returned"]
    pub fn iio_channel_get_index(chn: *const iio_channel) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get a pointer to a channel's data format structure\n @param chn A pointer to an iio_channel structure\n @return A pointer to the channel's iio_data_format structure"]
    pub fn iio_channel_get_data_format(chn: *const iio_channel) -> *const iio_data_format;
}
extern "C" {
    #[doc = " @brief Convert the sample from hardware format to host format\n @param chn A pointer to an iio_channel structure\n @param dst A pointer to the destination buffer where the converted sample\n should be written\n @param src A pointer to the source buffer containing the sample"]
    pub fn iio_channel_convert(
        chn: *const iio_channel,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Convert the sample from host format to hardware format\n @param chn A pointer to an iio_channel structure\n @param dst A pointer to the destination buffer where the converted sample\n should be written\n @param src A pointer to the source buffer containing the sample"]
    pub fn iio_channel_convert_inverse(
        chn: *const iio_channel,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Enumerate the debug attributes of the given device\n @param dev A pointer to an iio_device structure\n @return The number of debug attributes found"]
    pub fn iio_device_get_debug_attrs_count(dev: *const iio_device) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Get the debug attribute present at the given index\n @param dev A pointer to an iio_device structure\n @param index The index corresponding to the debug attribute\n @return On success, a pointer to a static NULL-terminated string\n @return If the index is invalid, NULL is returned"]
    pub fn iio_device_get_debug_attr(
        dev: *const iio_device,
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Try to find a debug attribute by its name\n @param dev A pointer to an iio_device structure\n @param name A NULL-terminated string corresponding to the name of the\n debug attribute\n @return On success, a pointer to a static NULL-terminated string\n @return If the name does not correspond to any known debug attribute of the\n given device, NULL is returned\n\n <b>NOTE:</b> This function is useful to detect the presence of a debug\n attribute.\n It can also be used to retrieve the name of a debug attribute as a pointer\n to a static string from a dynamically allocated string."]
    pub fn iio_device_find_debug_attr(
        dev: *const iio_device,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Read the content of the given debug attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n debug attribute\n @param dst A pointer to the memory area where the NULL-terminated string\n corresponding to the value read will be stored\n @param len The available length of the memory area, in bytes\n @return On success, the number of bytes written to the buffer\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b>By passing NULL as the \"attr\" argument to\n iio_device_debug_attr_read, it is now possible to read all of the debug\n attributes of a device.\n\n The buffer is filled with one block of data per debug attribute of the\n device, by the order they appear in the iio_device structure.\n\n The first four bytes of one block correspond to a 32-bit signed value in\n network order. If negative, it corresponds to the errno code that were\n returned when reading the debug attribute; if positive, it corresponds\n to the length of the data read. In that case, the rest of the block contains\n the data."]
    pub fn iio_device_debug_attr_read(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Read the content of all debug attributes\n @param dev A pointer to an iio_device structure\n @param cb A pointer to a callback function\n @param data A pointer that will be passed to the callback function\n @return On success, 0 is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> This function is especially useful when used with the network\n backend, as all the debug attributes are read in one single command."]
    pub fn iio_device_debug_attr_read_all(
        dev: *mut iio_device,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                dev: *mut iio_device,
                attr: *const ::std::os::raw::c_char,
                value: *const ::std::os::raw::c_char,
                len: usize,
                d: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given debug attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n debug attribute\n @param src A NULL-terminated string to set the debug attribute to\n @return On success, the number of bytes written\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b>By passing NULL as the \"attr\" argument to\n iio_device_debug_attr_write, it is now possible to write all of the\n debug attributes of a device.\n\n The buffer must contain one block of data per debug attribute of the device,\n by the order they appear in the iio_device structure.\n\n The first four bytes of one block correspond to a 32-bit signed value in\n network order. If negative, the debug attribute is not written; if positive,\n it corresponds to the length of the data to write. In that case, the rest\n of the block must contain the data."]
    pub fn iio_device_debug_attr_write(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Set the value of the given debug attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n debug attribute\n @param src A pointer to the data to be written\n @param len The number of bytes that should be written\n @return On success, the number of bytes written\n @return On error, a negative errno code is returned"]
    pub fn iio_device_debug_attr_write_raw(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Set the values of all debug attributes\n @param dev A pointer to an iio_device structure\n @param cb A pointer to a callback function\n @param data A pointer that will be passed to the callback function\n @return On success, 0 is returned\n @return On error, a negative errno code is returned\n\n <b>NOTE:</b> This function is especially useful when used with the network\n backend, as all the debug attributes are written in one single command."]
    pub fn iio_device_debug_attr_write_all(
        dev: *mut iio_device,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                dev: *mut iio_device,
                attr: *const ::std::os::raw::c_char,
                buf: *mut ::std::os::raw::c_void,
                len: usize,
                d: *mut ::std::os::raw::c_void,
            ) -> isize,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given debug attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n debug attribute\n @param val A pointer to a bool variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_debug_attr_read_bool(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given debug attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n debug attribute\n @param val A pointer to a long long variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_debug_attr_read_longlong(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the content of the given debug attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n debug attribute\n @param val A pointer to a double variable where the value should be stored\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_debug_attr_read_double(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given debug attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n debug attribute\n @param val A bool value to set the debug attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_debug_attr_write_bool(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given debug attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n debug attribute\n @param val A long long value to set the debug attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_debug_attr_write_longlong(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of the given debug attribute\n @param dev A pointer to an iio_device structure\n @param attr A NULL-terminated string corresponding to the name of the\n debug attribute\n @param val A double value to set the debug attribute to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_debug_attr_write_double(
        dev: *const iio_device,
        attr: *const ::std::os::raw::c_char,
        val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Identify the channel or debug attribute corresponding to a filename\n @param dev A pointer to an iio_device structure\n @param filename A NULL-terminated string corresponding to the filename\n @param chn A pointer to a pointer of an iio_channel structure. The pointed\n pointer will be set to the address of the iio_channel structure if the\n filename correspond to the attribute of a channel, or NULL otherwise.\n @param attr A pointer to a NULL-terminated string. The pointer\n pointer will be set to point to the name of the attribute corresponding to\n the filename.\n @return On success, 0 is returned, and *chn and *attr are modified.\n @return On error, a negative errno code is returned. *chn and *attr are not\n modified."]
    pub fn iio_device_identify_filename(
        dev: *const iio_device,
        filename: *const ::std::os::raw::c_char,
        chn: *mut *mut iio_channel,
        attr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of a hardware register\n @param dev A pointer to an iio_device structure\n @param address The address of the register\n @param value The value to set the register to\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_reg_write(
        dev: *mut iio_device,
        address: u32,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the value of a hardware register\n @param dev A pointer to an iio_device structure\n @param address The address of the register\n @param value A pointer to the variable where the value will be written\n @return On success, 0 is returned\n @return On error, a negative errno code is returned"]
    pub fn iio_device_reg_read(
        dev: *mut iio_device,
        address: u32,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
